{"version":3,"sources":["webpack:///webpack/bootstrap a4303a9950c4ee9d184a","webpack:///./src/app.js","webpack:///./src/models/elastic_centred_collision.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2BAA2B;AAC5C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B;AAC3B,2BAA2B;AAC3B,yBAAyB;AACzB,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;;;;;;;ACvpCA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a4303a9950c4ee9d184a","var elasticCentredCollision = require('./models/elastic_centred_collision')\n\nvar playGame = function() {\n\n  // State variable - all game state is on this object!\n  // Allows persistent properties between browser animation frames,\n  // pausing, etc.\n  var state = {}\n  state.version = {}\n  state.version.number = \"0.0.1\"\n  state.version.description = \"Webpack use started\"\n\n  // Shortcuts to common constants here\n  var degreesToRadians = Math.PI / 180\n  var radiansToDegrees = 1 / degreesToRadians\n\n  var developerTestFunction = function() {\n    // Developer tool\n    // When 'Z' is pressed, run this function\n    // Typical use: log a calculation which is to be tested\n\n    // var calc = testFunction()\n    console.log(\"This (outer)\", this)\n    var calc = elasticCentredCollision(1)\n    console.log(\"Result\", calc)\n  }\n\n  var updateMassGameCoords = function(mass) {\n    // Get state variables\n    var grav = state.world.gravity        // Pixels per second per second\n    var dT = 0.001 * state.control.timing.msBetweenLoops    // in seconds\n    // Get mass variables\n    var x = mass.x\n    var y = mass.y\n    var u = mass.u\n    var v = mass.v\n    var angVeloc = mass.angVeloc\n    var massAngle = mass.angle\n    // Update mass variables\n    x += dT * u\n    y += dT * v\n    massAngle = ( massAngle + dT * angVeloc) % 360\n    if (mass.affectedByGravity) {\n      v += dT * grav * mass.gravityMultiple   // Multiple is usually 1!\n    }\n    // Save mass variables if change is possible\n    if (mass.moves) {\n      mass.x = x\n      mass.u = u\n      mass.y = y\n      mass.v = v\n      mass.angle = massAngle\n      mass.angVeloc = angVeloc\n    }\n    // Deal with the game coordinates of the rotated parts\n    var angle = 0\n    var radius = 0\n    var angleRadians = 0\n    for (var i in mass.angleRadii) {\n      angle = mass.angleRadii[i][0] + massAngle\n      radius = mass.angleRadii[i][1]\n      angleRadians = angle * degreesToRadians\n      mass.gameCoords[i][0] = x + radius * Math.sin(angleRadians)\n      mass.gameCoords[i][1] = y + radius * Math.cos(angleRadians)\n    }\n    mass.gameCoordsValid = true\n  }\n\n  var updateMassesGameCoords = function() {\n    for (var mass of state.world.masses) {\n      if (!mass.gameCoordsValid || mass.moves) {\n        updateMassGameCoords(mass)\n      }\n    }\n  }\n\n  var mapCoordsGameToCanvas = function(gameCoordArray, canvasCoordArray, extraZoom, wrapIndep) {\n    // Use gameCoordArray and current game state\n    // to recalculate and overwrite the viewCoords\n    // Want the two arrays to be the same size\n    // which is an array of size N, of arrays of size 2\n\n    // Use wrapIndep only if different coordinates should be wrapped independently,\n    // e.g. for the stars background.\n\n    // extraZoom can be:\n    // 1) A number\n    // 2) An array of numbers, same size as other arrays\n    var useZoomArray = Array.isArray(extraZoom)\n\n    var canvasMidX = state.output.canvasDims.centre.x\n    var canvasMidY = state.output.canvasDims.centre.y\n    var viewMidX = state.output.view.pos.x\n    var viewMidY = state.output.view.pos.y\n    var viewZoom = state.output.view.zoom\n    var overallZoom = null\n\n    // Wrapping coordinates\n    // Need the world to have width and height\n    // bigger than the screen otherwise objects start\n    // disappearing at the side of the screen, and\n    // reappearing on the other side.\n    var wrapX = state.world.wrapCoords.x\n    var wrapY = state.world.wrapCoords.y\n    var actualWrapX = null\n    var actualWrapY = null\n    var canvasWrapX = null\n    var canvasWrapY = null\n\n    var gameCoord = [0, 0]\n    var gameX = 0\n    var gameY = 0\n    var canvasX = 0\n    var canvasY = 0\n    var canvasCoord = [0, 0]\n    for (var i=0; i < gameCoordArray.length; i++) {\n      if (useZoomArray) {\n        overallZoom = viewZoom * extraZoom[i]\n      } else {\n        overallZoom = viewZoom * extraZoom\n      }\n      actualWrapX = wrapX * overallZoom\n      actualWrapY = wrapY * overallZoom\n      gameCoord = gameCoordArray[i]\n      gameX = gameCoord[0]\n      gameY = gameCoord[1]\n      canvasX = canvasMidX + overallZoom * (gameX - viewMidX)    // Game coords start in bottom left, but\n      canvasY = canvasMidY - overallZoom * (gameY - viewMidY)    // Canvas coords start in top left\n\n      if (i===0 || wrapIndep===true) {\n        canvasWrapX = Math.round((canvasX - canvasMidX) / actualWrapX)\n        canvasWrapY = Math.round((canvasY - canvasMidY) / actualWrapY)\n      }\n\n      canvasCoord = [canvasX - actualWrapX * canvasWrapX, canvasY - actualWrapY * canvasWrapY]\n      // canvasCoord = [canvasX, canvasY]   // This is the unwrapped version!\n      canvasCoordArray[i] = canvasCoord\n    }\n  }\n\n  var updateMassesCanvasCoords = function() {\n    var backZoomOut = 0\n    var backZoom = 0\n    for (var mass of state.world.masses) {\n      mapCoordsGameToCanvas(mass.gameCoords, mass.canvasMainCoords, 1)\n      backZoomOut = mass.graphics.back.zoomOut\n      backZoomOut > 1 ? backZoom = 1/backZoomOut : backZoom = 1 //0.9  // Sensible default\n      mapCoordsGameToCanvas(mass.gameCoords, mass.canvasBackCoords, backZoom)\n    }\n  }\n\n  var doTiming = function(tFrame) {\n    var prevLoopStart = state.control.timing.thisLoopStart\n    var thisLoopStart = tFrame\n    if (state.control.pausing.timingNeedsResetting) {\n      // Reset the prevLoopStart since its going to be a long time ago!\n      prevLoopStart = thisLoopStart - 8        // Between 0 and 16. 8 smooth.\n      state.control.pausing.timingNeedsResetting = false\n    }\n    var msBetweenLoops = thisLoopStart-prevLoopStart\n    state.control.timing.prevLoopStart = prevLoopStart\n    state.control.timing.thisLoopStart = thisLoopStart\n    state.control.timing.msBetweenLoops = msBetweenLoops\n    state.player.time += 0.001 * msBetweenLoops\n  }\n\n  var updateViewCoords = function() {\n    // var prevX = state.output.view.pos.x    // Pixels\n    // var prevY = state.output.view.pos.y    // Pixels\n    var followX = state.player.ship.x\n    var followY = state.player.ship.y\n    var followU = state.player.ship.u\n    var followV = state.player.ship.v\n    // Two constants controlling how swiftly view responds to velocity\n    var velConst = state.constants.view.velFactor\n    var radiusConst = state.constants.view.radiusFactor\n    // Get a magnitude and angle from velocity\n    // which will determine how view relates to ship\n    var shipVelMagSq = followU ** 2 + followV ** 2      // Leave this squared so low speeds not much happens\n    var shipVelAng = radiansToDegrees * Math.atan(followU/followV)\n    if (followV<0) {\n      shipVelAng += 180\n    }\n    // Use the atan function\n    // Smooth movement around the ship\n    var viewMoveDistance = radiusConst * 0.6366 * Math.atan(velConst * shipVelMagSq)\n    // Factor of 0.6366 is 1/arctan(Inf)\n\n    // var dX = followX-prevX\n    // var dY = followY-prevY\n    // var d2 = state.player.ship.u**2 + state.player.ship.v**2\n    // Sometimes view can stay behind the player ship so far\n    // it is off the screen! Fix this.\n    state.output.view.pos.x = followX + viewMoveDistance * (\n      Math.sin(degreesToRadians * shipVelAng)\n    )\n    state.output.view.pos.y = followY + viewMoveDistance * (\n      Math.cos(degreesToRadians * shipVelAng)\n    )\n    // state.output.view.pos.y = followY + radiusConst * followV\n    // When the player ship stops momentarily, the screen zooms in and out\n    // very fast. Fix this.\n    // Note - changing the zoom will make stars go off\n    // the side of the screen, if the constants aren't\n    // calibrated... more work needed here.\n    state.output.view.zoom = 1  //0.92+0.08/(1+0.0001*d2)\n  }\n\n  var drawLineSet = function(coordsArray){\n    var context = state.output.context\n    context.beginPath()\n    var posX = coordsArray[0][0]\n    var posY = coordsArray[0][1]\n    context.moveTo(posX, posY)\n    for (var i=1; i<coordsArray.length; i++){\n      posX = coordsArray[i][0]\n      posY = coordsArray[i][1]\n      // Do the bounding of the coords in the earlier calc function?\n      // posX<boundLeft ? posX=boundLeft : null\n      // posX>boundRight ? posX=boundRight : null\n      // posY<boundUp ? posY=boundUp : null\n      // posY>boundDown ? posY=boundDown : null\n      context.lineTo(posX, posY)\n    }\n    context.stroke()\n    context.fill()\n    // context.closePath()\n  }\n\n  var drawMassCentresAsPoints = function() {\n    // Draw a dot on the centre of mass for each mass\n    var context = state.output.context\n    var canvasCoords = [[0, 0]]\n    var dotSize = 2\n    for (var i in state.world.masses) {\n      massGameX = state.world.masses[i].x\n      massGameY = state.world.masses[i].y\n      mapCoordsGameToCanvas([[massGameX, massGameY]], canvasCoords, 1)\n      context.fillStyle = \"#FFF\"\n      context.fillRect(canvasCoords[0][0], canvasCoords[0][1], dotSize, dotSize)\n    }\n  }\n\n  var drawMassesOntoCanvas = function() {\n    var mass = null\n    var context = state.output.context\n    for (var i in state.world.masses) {\n      mass = state.world.masses[i]\n      if (mass.graphics.back.isDrawn) {\n        context.strokeStyle = mass.graphics.back.strokeStyle\n        context.lineWidth = mass.graphics.back.lineWidth\n        context.fillStyle = mass.graphics.back.fillStyle\n        drawLineSet(mass.canvasBackCoords)\n      }\n    }\n    for (var i in state.world.masses) {\n      mass = state.world.masses[i]\n      context.strokeStyle = mass.graphics.main.strokeStyle\n      context.lineWidth = mass.graphics.main.lineWidth\n      context.fillStyle = mass.graphics.main.fillStyle\n      drawLineSet(mass.canvasMainCoords)\n    }\n    if (state.output.view.markCentreOfMass) {\n      drawMassCentresAsPoints()\n    }\n  }\n\n  var drawStarsOntoCanvas = function() {\n    var context = state.output.context\n    mapCoordsGameToCanvas(\n      state.world.stars.gameCoords,\n      state.world.stars.canvasCoords,\n      state.world.stars.zoomIns,\n      true\n    )\n    // the 'true' on the end does the canvas wrapping independently for each star\n    // unlike most objects in the game (e.g. solid masses) which wrap together.\n    var starX = 0   // These to be overwritten\n    var starY = 0\n    var starCol = \"#FFF\"\n    var starSize = 2\n    for (var i in state.world.stars.canvasCoords) {\n      starX = state.world.stars.canvasCoords[i][0]\n      starY = state.world.stars.canvasCoords[i][1]\n      starCol = state.world.stars.colours[i]\n      starSize = state.world.stars.sizes[i]\n      context.fillStyle = starCol\n      context.fillRect(starX, starY, starSize, starSize)\n    }\n  }\n\n  var clearCanvas = function(){\n    // Set up drawing\n    var canvasLeft = state.output.canvasDims.bounds.left\n    var canvasRight = state.output.canvasDims.bounds.right\n    var canvasUp = state.output.canvasDims.bounds.up\n    var canvasDown = state.output.canvasDims.bounds.down\n    var context = state.output.context\n    // Do drawing\n    context.clearRect(canvasLeft, canvasUp, canvasRight-canvasLeft, canvasDown-canvasUp)\n    // context.fillStyle=\"black\";\n    // context.fillRect(canvasLeft, canvasUp, canvasRight-canvasLeft, canvasDown-canvasUp)\n  }\n\n  var drawCanvas = function(){\n    clearCanvas()\n    drawStarsOntoCanvas()\n    drawMassesOntoCanvas()\n  }\n\n  var updateTextInHtml = function(){\n    if (state.control.loopCount % 7 === 0) {\n      state.output.pageElts.time.innerText = Math.round(state.player.time)\n      state.output.pageElts.fuel.innerText = Math.round(state.player.fuel)\n      state.output.pageElts.ammo.innerText = Math.round(state.player.ammo)\n      state.output.pageElts.health.innerText = Math.round(state.player.health)\n      state.output.pageElts.coin.innerText = Math.round(state.player.coin)\n      state.output.pageElts.x.innerText = Math.round(state.player.ship.x)\n      state.output.pageElts.y.innerText = Math.round(state.player.ship.y)\n      state.output.pageElts.u.innerText = Math.round(state.player.ship.u)\n      state.output.pageElts.v.innerText = Math.round(state.player.ship.v)\n      state.output.pageElts.anglePos.innerText = Math.round(state.player.ship.angle)\n      state.output.pageElts.angleVel.innerText = Math.round(state.player.ship.angVeloc)\n      state.output.pageElts.renderTimeElt.innerText = Math.round(state.control.timing.msRenderTime )\n    }\n  }\n\n  var fireBullet = function() {\n    var bulletMaxRadius = 7\n    var bulletDeformity = Math.round((bulletMaxRadius-1)*Math.random())\n    var bulletRelativeSpeed = 300\n    var bulletVelocRecoil = 20\n    var bulletSpinRecoil = 0.5\n    var bulletSides = 3 + Math.round(30 * Math.random()**10)   // Bias towards fewer edges\n    var spin = 400 * (-0.5 + Math.random())\n    var bulletX = state.player.ship.x + 50 * Math.sin(degreesToRadians * state.player.ship.angle)\n    var bulletY = state.player.ship.y + 50 * Math.cos(degreesToRadians * state.player.ship.angle)\n    var bullet = addNewMass(bulletX, bulletY, bulletSides, bulletMaxRadius, bulletMaxRadius-bulletDeformity, 3)\n    bullet.massType = \"bullet\"\n    bullet.moves = true\n    bullet.affectedByGravity = true\n    bullet.gravityMultiple = 0.1\n    bullet.isWall = false\n    bullet.u = state.player.ship.u + bulletRelativeSpeed * Math.sin(degreesToRadians * state.player.ship.angle)\n    bullet.v = state.player.ship.v + bulletRelativeSpeed * Math.cos(degreesToRadians * state.player.ship.angle)\n    bullet.angVeloc = spin\n    bullet.graphics.main.fillStyle = \"#0F0\"\n    bullet.graphics.main.strokeStyle = \"#FFF\"\n    bullet.graphics.main.lineWidth = 3\n    bullet.graphics.back.zoomOut = 1.03 + 0.05 * Math.random()\n    bullet.graphics.back.fillStyle = \"#F0F\"\n    bullet.graphics.back.strokeStyle = \"#888\"\n    bullet.graphics.back.lineWidth = 3\n    if (Math.random()<0.015) {\n      bullet.graphics.back.fillStyle = \"#F00\"\n      bullet.graphics.back.strokeStyle = \"#FFF\"\n    }\n    if (Math.random()<0.004) {\n      bullet.graphics.main.fillStyle = \"#FF0\"\n      bullet.graphics.main.strokeStyle = \"#00F\"\n    }\n    state.player.ship.u -= bulletVelocRecoil * Math.sin(degreesToRadians*state.player.ship.angle)\n    state.player.ship.v -= bulletVelocRecoil * Math.cos(degreesToRadians*state.player.ship.angle)\n    state.player.ship.angVeloc -= bulletSpinRecoil * spin\n    state.player.ammo--\n  }\n\n  var measureModularOffset = function(coord1, coord2, wrapDistance) {\n    // var halfDistance = 0.5 * wrapDistance    // Slower\n    var halfDistance = wrapDistance >> 1        // Faster!\n    var result = (coord2-coord1) % wrapDistance\n    // For positive result, between 0 and wrapDistance\n    // For negative result, between -wrapDistance and 0\n    // If abs value greater than halfDistance, find a number closer to 0\n    if (halfDistance < result) {\n      result -= wrapDistance\n    } else if (result < -halfDistance) {\n      result += wrapDistance\n    }\n    return result\n  }\n\n  var measureDistance = function(x1, y1, x2, y2) {\n    var offsetX = measureModularOffset(x1, x2, state.world.wrapCoords.x)\n    var offsetY = measureModularOffset(y1, y2, state.world.wrapCoords.y)\n    // Offsets are from -wrap/2 to +wrap/2 in each direction\n    return Math.sqrt(offsetX**2 + offsetY**2)\n  }\n\n  var measureAngleDegrees = function(x1, y1, x2, y2) {\n    // See where mass game-coords are calculated\n    // In degrees:\n    // Up=0, up-right=45, right=90, right-down=135, down=180\n    // Down+1 = -179, down-left=-135, left=-90, left-up = -45, up=0\n    var xD = measureModularOffset(x1, x2, state.world.wrapCoords.x)\n    var yD = measureModularOffset(y1, y2, state.world.wrapCoords.y)\n    // Deal with case x offset = 0\n    if (xD === 0) {\n      // Will prevent division by zero below\n      if (yD < 0) {\n        return 180    // (0, -1) returns 180 degrees\n      } else {\n        return 0      // (0, 0) and (0, 1) returns 0 degrees\n      }\n    }\n    // Deal with case x offset < 1\n    var resultSign = 1\n    if (xD < 0) {\n      resultSign = -1\n      xD = -xD\n    }\n    // Final case: x offset > 1\n    var angle = radiansToDegrees * Math.atan(yD/xD)\n    // angle = 0 for 'right'\n    // angle -> 90 for 'up'\n    // angle -> -90 for 'down'\n    return resultSign * (90 - angle)\n  }\n\n  var checkIfTrulyCollided = function(i, j) {\n    // Maximum radii coincide\n    // Might or might not be a collision\n    // For now - assume there is!\n    // More work needed here!\n    return true\n  }\n\n  var markAsCollided = function(i, j) {\n    // Calculate collision angle\n    var angle = measureAngleDegrees(\n      state.world.masses[i].x, state.world.masses[i].y,\n      state.world.masses[j].x, state.world.masses[j].y\n    )\n\n    // // DEBUG\n    // var offsetXR = Math.round(measureModularOffset(\n    //   state.world.masses[i].x, state.world.masses[j].x, state.world.wrapCoords.x\n    // ))\n    // var offsetYR = Math.round(measureModularOffset(\n    //   state.world.masses[i].y, state.world.masses[j].y, state.world.wrapCoords.y\n    // ))\n    // var distanceR = Math.round(measureDistance(\n    //   state.world.masses[i].x, state.world.masses[i].y,\n    //   state.world.masses[j].x, state.world.masses[j].y\n    // ))\n    // console.log(\"Collision: offset\", offsetXR, offsetYR, \", distance\", distanceR, \", angle\", Math.round(angle))\n\n    var massI = state.world.masses[i].mass\n    var massJ = state.world.masses[j].mass\n    var massRatioOfI = massI/(massI+massJ)\n    var massRatioOfJ = 1 - massRatioOfI\n    // Mark i as having collided with j\n    // (Direction of the angle is the direction of the force on each element)\n    state.world.masses[i].collisionWith.index = j\n    state.world.masses[i].collisionWith.mass = massJ\n    state.world.masses[i].collisionWith.u = state.world.masses[j].u\n    state.world.masses[i].collisionWith.v = state.world.masses[j].v\n    state.world.masses[i].collisionWith.angVeloc = state.world.masses[j].angVeloc\n    state.world.masses[i].collisionWith.angle = -angle\n    state.world.masses[i].collisionWith.massRatio = massRatioOfJ\n    // Mark j as having collided with i\n    state.world.masses[j].collisionWith.index = i\n    state.world.masses[j].collisionWith.mass = massI\n    state.world.masses[j].collisionWith.u = state.world.masses[i].u\n    state.world.masses[j].collisionWith.v = state.world.masses[i].v\n    state.world.masses[j].collisionWith.angVeloc = state.world.masses[i].angVeloc\n    state.world.masses[j].collisionWith.angle = angle\n    state.world.masses[j].collisionWith.massRatio = massRatioOfI\n  }\n\n  var findCollisionsBetweenMasses = function() {\n    // Currently checking almost all pairs of masses\n    // This could be done smarter when there are a lot of masses!\n    var xi = 0\n    var xj = 0\n    var yi = 0\n    var yj = 0\n    var ri = 0\n    var rj = 0\n    var distance = 0\n    var radiusSum = 0\n    var countMasses = state.world.masses.length\n    for (var i=0; i<countMasses; i++) {\n      // Only allow one collision per mass per frame\n      if (state.world.masses[i].collisionWith.index === null) {\n        xi = state.world.masses[i].x\n        yi = state.world.masses[i].y\n        ri = state.world.masses[i].maxRadius\n        for (var j=i+1; j<countMasses; j++) {\n          if (state.world.masses[j].collisionWith.index === null) {\n            // Ignore wall-wall collisions at the moment\n            if (!(state.world.masses[i].isWall && state.world.masses[j].isWall)) {\n              xj = state.world.masses[j].x\n              yj = state.world.masses[j].y\n              rj = state.world.masses[j].maxRadius\n              distance = measureDistance(xi, yi, xj, yj)\n              radiusSum = ri+rj\n              if (distance < radiusSum) {\n                if (checkIfTrulyCollided(i, j)) {\n                  markAsCollided(i, j)\n                  break\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var dealWithCollision = function(mass) {\n    // Angular velocity currently not changed\n    // Here are the relevant variables for elastic collisions\n    var m1 = mass.mass\n    var u1 = mass.u\n    var v1 = mass.v\n    var m2 = mass.collisionWith.mass\n    var u2 = mass.collisionWith.u\n    var v2 = mass.collisionWith.v\n    var angleM1M2 = -mass.collisionWith.angle\n\n    // Some setup\n    var damping = state.constants.collisions.dampingFactor\n    var massSumInv = 1/(m1+m2)\n    var massDiff = m1-m2\n    var massRatioOfOther = mass.collisionWith.massRatio\n    var moveAwayPx = state.constants.collisions.moveAwayPx\n\n    // Function elasticCentredCollision to find new (u, v)\n    // var newVelocArray = elasticCentredCollision(angleM1M2, m1, u1, v1, m2, u2, v2)\n\n    // NEW METHOD\n\n    // OLD METHOD\n    // Change the momentum according to a (damped) elastic collision\n    // See: https://en.wikipedia.org/wiki/Elastic_collision\n    var angleDirectlyAway = -angleM1M2\n    mass.u = damping * massSumInv * (u1 * massDiff + 2*m2*u2 )\n    mass.v = damping * massSumInv * (v1 * massDiff + 2*m2*v2 )\n    // Move the colliding parties slightly away from each other\n    mass.x += massRatioOfOther * moveAwayPx * Math.sin(degreesToRadians * angleDirectlyAway)\n    mass.y += massRatioOfOther * moveAwayPx * Math.cos(degreesToRadians * angleDirectlyAway)\n\n    // If its a bullet, mark it for removal\n    if (mass.massType === \"bullet\") {\n      // mass.toBeRemoved = true\n    }\n    // NOT DONE - instead want some kind of damage function which\n\n    // Dealt with collision now. Mark it as not collided\n    mass.collisionWith.index = null\n    // Could also reset the other variables here,\n    // but that's less important.\n  }\n\n  var dealWithCollisions = function() {\n    for (var mass of state.world.masses) {\n      if (mass.collisionWith.index !== null) {\n        dealWithCollision(mass)\n      }\n    }\n  }\n\n  var respondReliablyToKeyUps = function(eventKeyboardCode) {\n    // This runs in background, even if the main loop isn't running!\n    if ( eventKeyboardCode === \"KeyP\" || eventKeyboardCode === \"KeyQ\" ) {\n      // P is pause button. Q is extra pause button, easier positioning\n      // Done on key-up, since keydown was more complicated and unreliable\n      if (state.control.pausing.isPaused) {\n        // Restart main loop!\n        state.control.pausing.isPaused = false\n        state.control.pausing.timingNeedsResetting = true\n        window.requestAnimationFrame(mainLoop)\n      } else {\n        state.control.pausing.isPaused = true\n        // This will stop the next animation frame\n      }\n    }\n    if (eventKeyboardCode===\"KeyZ\") {\n      // Developer function\n      // Run a test function from within the game\n      // This function can be switched to do whatever you want to measure.\n      // Typically, console log the output of another function to test\n      developerTestFunction()\n    }\n    if (eventKeyboardCode===\"KeyX\") {\n      // Developer function\n      // Turn COM dots off/on\n      if (state.output.view.markCentreOfMass) {\n        state.output.view.markCentreOfMass = false\n      } else {\n        state.output.view.markCentreOfMass = true\n      }\n    }\n  }\n\n  var respondReliablyToKeyDowns = function(eventKeyboardCode) {\n    // This runs, even if the main loop isn't running!\n    // Currently nothing extra to do,\n    // on top of what's already controlled by main loop\n  }\n\n  var respondToKeyboardDuringMainLoop = function() {\n    // This only runs when main loop is active\n    if (state.player.fuel > 0) {\n      // Turn left\n      if (state.input.keyboard.ArrowLeft) {\n        state.player.ship.angVeloc -= 15\n        state.player.fuel -= 0.001\n      }\n      // Turn right\n      if (state.input.keyboard.ArrowRight) {\n        state.player.ship.angVeloc += 15\n        state.player.fuel -= 0.001\n      }\n      // Rotate freely\n      if (!state.input.keyboard.ArrowLeft && !state.input.keyboard.ArrowRight) {\n        state.player.ship.angVeloc *= 0.92\n        // If deducting fuel, make it proportional to abs of angVeloc\n      }\n      // Stop rotating\n      if (state.input.keyboard.ArrowUp) {\n        state.player.ship.u += 10 * Math.sin(degreesToRadians*state.player.ship.angle)\n        state.player.ship.v += 10 * Math.cos(degreesToRadians*state.player.ship.angle)\n        state.player.fuel -= 0.005\n      }\n    }\n    if (state.player.ammo > 0) {\n      // Fire bullet\n      if (state.input.keyboard.Space) {\n        fireBullet()\n        state.input.keyboard.Space = false\n        // One bullet per SPACE press\n        // Deal with auto-repeat keydowns in future\n      }\n    }\n  }\n\n  var recalculatePhysicsStats = function(mass) {\n    var density = mass.density\n    var angleRadii = mass.angleRadii\n    var calcMass = 0\n    var a1 = 0\n    var a2 = 0\n    var r1 = 0\n    var r2 = 0\n    var area = 0\n    var segments = angleRadii.length - 1\n    var maxRadius = angleRadii[0][1]\n    for (var i=0; i<segments; i++) {\n      a1 = angleRadii[i][0]\n      r1 = angleRadii[i][1]\n      a2 = angleRadii[i+1][0]\n      r2 = angleRadii[i+1][1]\n      area = 0.5 * r1 * r2 * Math.sin ( degreesToRadians * (a2-a1) )  // Sine area rule\n      calcMass += density * area\n      maxRadius = Math.max(maxRadius, r2)\n    }\n    mass.mass = calcMass**1.5  // Pseudo-3D calculation here - turn 2D mass into 3D\n    mass.maxRadius = maxRadius;\n    mass.physicsStatsInvalid = false\n  }\n\n  var recalculateAllPhysicsStats = function() {\n    for (var mass in state.world.masses) {\n      if (mass.physicsStatsInvalid) {\n        recalculatePhysicsStats(mass)\n      }\n    }\n  }\n\n  var removeDeadMasses = function() {\n    var countMasses = state.world.masses.length\n    var counter = 0\n    while (counter < countMasses) {\n      if (state.world.masses[counter].toBeRemoved) {\n        state.world.masses.splice(counter, 1)\n        countMasses--\n        counter--\n      }\n      counter++\n    }\n  }\n\n  var wrapCoordsOptional = function(){\n    // Use this to map game coordinates to +/- half of the\n    // wrapping distance in each direction.\n    // Doesn't absolutely have to be done, but\n    // its neater to do it.\n\n    // Could, for example, allow coords to be +/- whole wrapping distance,\n    // but map to within half the wrapping distance.\n    // That way the modular arithmetic will still be put to some use!\n  }\n\n  var addNewMass = function(x, y, points, maxRadius, minRadius, density) {\n    // There is randomisation between minRadius and maxRadius\n    // Set these as equal for a deterministic mass (e.g. the ship, or a round bullet)\n    // points are currently evenly spread around 360 degrees.\n    var newMass = {}\n    newMass.massType = \"wall\"\n    newMass.isWall = true       // Use this to ignore wall-wall collisions\n    newMass.density = density   // Used to calculate mass\n    newMass.mass = 1            // Recalculated later\n    newMass.toBeRemoved = false   // Use this to mark masses for removal before next loop\n    newMass.x = x\n    newMass.y = y\n    newMass.graphics = {}\n    // Foreground / Main rendered at zoom = zoomOut = 1\n    // Background rendered at higher zoomOut > 1  (zoomOut = 1/zoom)\n    newMass.graphics.main = {}\n    newMass.graphics.back = {}\n    newMass.graphics.back.zoomOut = 1.1\n    newMass.graphics.back.isDrawn = true\n    newMass.graphics.main.fillStyle = \"#999\"\n    newMass.graphics.main.strokeStyle = \"#AC9\"\n    newMass.graphics.main.lineWidth = 3\n    newMass.graphics.back.fillStyle = \"#444\"\n    newMass.graphics.back.strokeStyle = \"#669\"\n    newMass.graphics.back.lineWidth = 2\n    // Note: state.world.masses will be rendered in the order they are stored!\n    // However, it will only look correct if the objects with\n    // higher zoomOuts are rendered first\n    // so there ought to be checking of order and sorting\n    // perhaps every 0.25 seconds (10 frames/loops or so)\n    newMass.angle = 0\n    newMass.maxRadius = maxRadius        // Recalculated later\n    newMass.moves = false\n    newMass.u = 0    // Anything which doesn't move should have u, v, angVeloc = 0\n    newMass.v = 0\n    newMass.angVeloc = 0\n    newMass.affectedByGravity = false  // Things should only be affected by gravity if they move!\n    newMass.gravityMultiple = 1        // A gravity multiplier. Can make things less or more affected!\n    newMass.angleRadii = []\n    // Give some space for dealing with collisions\n    newMass.collisionWith = {}\n    newMass.collisionWith.index = null\n    newMass.collisionWith.mass = 1\n    newMass.collisionWith.u = 0\n    newMass.collisionWith.v = 0\n    newMass.collisionWith.angVeloc = 0\n    newMass.collisionWith.angle = 0\n    newMass.collisionWith.massRatio = 0\n    // First element\n    var nextAngle = 0\n    var nextRadius = minRadius + (maxRadius-minRadius) * Math.random()\n    var nextElt = [nextAngle, nextRadius]\n    newMass.angleRadii.push(nextElt)\n    for (var i=1; i<points; i++) {\n      // Middle elements\n      nextAngle = 360 * i / points\n      nextRadius = minRadius + (maxRadius-minRadius) * Math.random()\n      nextElt = [nextAngle, nextRadius]\n      newMass.angleRadii.push(nextElt)\n    }\n    // Last element\n    nextAngle = 360\n    nextRadius = newMass.angleRadii[0][1]\n    nextElt = [nextAngle, nextRadius]\n    newMass.angleRadii.push(nextElt)\n    // (Re)calculate the important physics stats, such as maximum radius and mass\n    newMass.physicsStatsInvalid = true\n    recalculatePhysicsStats(newMass)\n    // Admin fields for the mass\n    !newMass.maxRadius ? newMass.maxRadius = 0 : null;\n    !newMass.gameCoordsValid ? newMass.gameCoordsValid = false : null\n    newMass.gameCoords = newMass.angleRadii.slice()   // Shallow copy! Need deep copy!\n    newMass.canvasMainCoords = newMass.angleRadii.slice()\n    newMass.canvasBackCoords = newMass.angleRadii.slice()\n    for (var i in newMass.gameCoords) {\n      newMass.gameCoords[i] = newMass.gameCoords[i].slice()  // Deep copy done here\n      newMass.canvasMainCoords[i] = newMass.canvasMainCoords[i].slice()\n      newMass.canvasBackCoords[i] = newMass.canvasBackCoords[i].slice()\n    }\n    // Add to game masses\n    state.world.masses.push(newMass)\n    return newMass\n  }\n\n  var setupState = function() {\n\n    // Setup main state categories here\n    state.constants = {}\n    // state.world = {}\n    state.worlds = {}      // World will point to one of the worlds!\n    state.player = {}\n    state.control = {}\n    state.input = {}\n    state.output = {}\n    state.output.pageElts = {}\n\n    state.constants.collisions = {}\n    state.constants.collisions.dampingFactor = 0.95     // Retain between 0 and 1 of momentum\n    state.constants.collisions.moveAwayPx = 3           // Move each mass slightly further away\n    // state.constants.collisions.lastCollisionTime = 0\n    // state.constants.collisions.timeBeforeNextCollision = 0.1  // Multiple collisions disallowed\n    // // since that leads to objects sticking together!\n    state.constants.view = {}\n    state.constants.view.velFactor = 10 ** -6.2\n    state.constants.view.radiusFactor = 300\n\n    // state.rockTypes = []\n    // var fullerene = {\n    //   type: \"fullerene\",\n    //   density: 0.5,\n    //   rgbInfo: \"too complicated\"\n    // }\n    // state.rockTypes.push(fullerene)\n    // state.rockTypes.fullerene = {}\n    // state.rockTypes.fullerene.density =\n    // state.rockTypes.fullerene.main = {}\n    //   density: 0.5,\n    // }\n    // state.rockTypes.ammonium = {\n    //   density: 0.5,\n    // }\n    // state.rockTypes.structrite = {\n    //   density: 0.5,\n    // }\n    // state.rockTypes.coinium = {\n    //   density: 0.5,\n    // }\n    // state.rockTypes.neutrite = {\n    //   density: 0.5,\n    // }\n\n    // Setup control variables\n    state.control.loopCount = 0\n    state.control.pausing = {}\n    state.control.pausing.isPaused = false\n    state.control.pausing.timingNeedsResetting = false\n    state.control.timing = {}\n    state.control.timing.prevLoopStart = window.performance.now()    // dummy data\n    state.control.timing.thisLoopStart = window.performance.now()\n    state.control.timing.msBetweenLoops = 10\n    state.control.timing.msRenderTime = 10\n\n    // Setup worlds hash\n    var world1Name = \"emptyWorld\"\n    state.worlds[world1Name] = {}\n    var world2Name = \"testWorld\"\n    state.worlds[world2Name] = {}\n    state.control.currentWorldName = world2Name\n    // Point the (current) world to the world stated in control\n    state.world = state.worlds[state.control.currentWorldName]\n\n    // Setup world maximum dimensions\n    // If things are bigger, they get wrapped around (modular arithmetic!)\n    // Note - no individual item should be anywhere near this big,\n    // since they will not display correctly, they will visibly flicker\n    // from left/right or top/down.\n    state.world.wrapCoords = {}\n    state.world.wrapCoords.x = 6000\n    state.world.wrapCoords.y = 4000\n    // Currently (2017_10_22) the screen is fixed at 1200x675 px (16:9 aspect ratio)\n    // Each of the dimensions for wrapCoords here needs to be\n    // significantly bigger than the screen dimension.\n    // Also, the stars will be very near unless these dimensions are big enough!\n\n    // Setup canvas, context and view\n    var canvasElt = document.querySelector(\"#main-canvas\")\n    var context = canvasElt.getContext('2d')\n    var boundLeft = 0\n    var boundRight = canvasElt.width\n    var boundUp = 0\n    var boundDown = canvasElt.height\n\n    state.output.canvasDims = {}\n    state.output.canvasDims.bounds = {}\n    state.output.canvasDims.bounds.left = boundLeft\n    state.output.canvasDims.bounds.right = boundRight\n    state.output.canvasDims.bounds.up = boundUp\n    state.output.canvasDims.bounds.down = boundDown\n    state.output.canvasDims.centre = {}\n    state.output.canvasDims.centre.x = (boundLeft+boundRight)/2\n    state.output.canvasDims.centre.y = (boundUp+boundDown)/2\n    state.output.canvasDims.size = {}\n    state.output.canvasDims.size.x = boundRight-boundLeft\n    state.output.canvasDims.size.y = boundDown-boundUp\n\n    // state.output.canvasDims.elt\n\n    // var canvasBounds = {left: boundLeft, right: boundRight, up: boundUp, down: boundDown}\n    // var canvasCentre = {x: (boundLeft+boundRight)/2, y: (boundUp+boundDown)/2}\n    // var canvasSize = {x: boundRight-boundLeft, y: boundDown-boundUp}\n    // var canvas = {elt: canvasElt, bounds: canvasBounds, centre: canvasCentre, size: canvasSize}\n    // state.output.canvasDims = canvas\n\n    // var context = canvasElt.getContext('2d')\n    // state.output.context = context\n\n    state.output.view = {}\n    state.output.view.zoom = 1\n    state.output.view.markCentreOfMass = true\n    state.output.view.pos = {}\n    state.output.view.pos.x = state.output.canvasDims.centre.x\n    state.output.view.pos.y = state.output.canvasDims.centre.y\n\n    // x, y are positions in pixels\n    // u, v are velocities in pixels per second\n\n    // Start the game masses array.\n    // This contains: the player ship, walls, bullets, enemies, etc.\n    state.world.masses = []\n\n    // Make some walls using the random mass\n    var xMin = -100\n    var xMax = 900\n    var yMin = -100\n    var yMax = 700\n    var step = 125\n    var points = 19     // Overridden randomly below\n    var maxRadius = 150\n    var minRadius = 40\n    var density = 10\n    // Make the set of points first\n    // Then generate the wall elements in a random order\n    var wallCoordSet = []\n    for (var x=xMin; x<=xMax; x+=step) {\n      wallCoordSet.push([x, yMin, Math.random()])\n      wallCoordSet.push([x, yMax, Math.random()])\n    }\n    for (var y=yMin+step; y<=yMax-step; y+=step) {\n      wallCoordSet.push([xMin, y, Math.random()])\n    }\n    // Leave a gap!\n    for (var y=yMin+step; y<=yMax-3*step; y+=step) {\n      wallCoordSet.push([xMax, y, Math.random()])\n    }\n    wallCoordSet.sort(function(elt2, elt1){\n      return elt2[2] - elt1[2]\n    })\n    var theMass = null\n    for (var i in wallCoordSet) {\n      points = 3 + Math.round(21*Math.random())\n      maxRadius = 50 + Math.round(150*Math.random())\n      minRadius = 10 + Math.round(0.9*maxRadius*Math.random())\n      theMass = addNewMass(wallCoordSet[i][0], wallCoordSet[i][1], points, maxRadius, minRadius, density)\n      theMass.graphics.back.zoomOut = 1.05 + 0.5*(1-wallCoordSet[i][2]**0.5)\n      theMass.moves = true\n\n      // // DEBUG\n      // theMass.toBeRemoved = true\n\n    }\n\n    var j=0\n    var jMax = state.world.masses.length - 1\n\n    // Make some of the game masses rotate!\n    for (var i=0; i<7; i++) {\n      j = Math.round(jMax * Math.random())\n      state.world.masses[j].moves = true\n      state.world.masses[j].angVeloc = -30 + 60 * Math.random()  // deg/s\n    }\n\n    // Make some of the game masses dark brown!\n    for (var i=0; i<9; i++) {\n      j = Math.round(jMax * Math.random())\n      state.world.masses[i].graphics.main.fillStyle = \"#997755\"\n      state.world.masses[i].graphics.main.strokeStyle = \"#AA6655\"\n      state.world.masses[i].graphics.back.fillStyle = \"#664422\"\n      state.world.masses[i].graphics.back.strokeStyle = \"#999922\"\n    }\n\n    // Make some of the game masses gold!\n    for (var i=0; i<3; i++) {\n      j = Math.round(jMax * Math.random())\n      state.world.masses[i].graphics.main.fillStyle = \"#998811\"\n      state.world.masses[i].graphics.main.strokeStyle = \"#AAAAEE\"\n      state.world.masses[i].graphics.back.fillStyle = \"#665511\"\n      state.world.masses[i].graphics.back.strokeStyle = \"#779977\"\n    }\n\n    // // DEBUG\n    // addNewMass(state.output.canvasDims.centre.x, state.output.canvasDims.centre.y - 800, 10, 600, 550, 10)\n\n    // Make the game player\n    var playerShip = addNewMass(state.output.canvasDims.centre.x, state.output.canvasDims.centre.y, 5, 41, 41, 0.3, 3)\n    playerShip.massType = \"ship\"\n    playerShip.angleRadii[1][1]=13\n    playerShip.angleRadii[2][1]=23\n    playerShip.angleRadii[3][1]=23\n    playerShip.angleRadii[4][1]=13\n    playerShip.moves = true\n    playerShip.affectedByGravity = true\n    playerShip.u = -40 + 80 * Math.random()\n    playerShip.v = 50 + 50 * Math.random()\n    playerShip.isWall = false\n    playerShip.angVeloc = 0\n    playerShip.graphics.main.fillStyle = \"#44F\"\n    playerShip.graphics.main.strokeStyle = \"#ACF\"\n    playerShip.graphics.main.lineWidth = 2\n    playerShip.graphics.back.isDrawn = false\n    // playerShip.graphics.back.fillStyle = \"#035\"\n    // playerShip.graphics.back.strokeStyle = \"#555\"\n    // playerShip.graphics.back.lineWidth = 2\n\n    // The world needs to know which of its masses is the player ship\n    state.world.playerShip = playerShip\n\n    // The player needs to know which of the masses\n    // (IN THE CURRENT WORLD!)\n    // is the player ship\n    state.player.ship = state.world.playerShip\n\n    // Other player ship related variables\n    state.player.time = 0\n    state.player.fuel = 100\n    state.player.ammo = 50\n    state.player.health = 100\n    state.player.coin = 0\n\n    // Monitor key presses\n    state.input.keyboard = {}\n    state.input.keyboard.ArrowLeft = false      // Rotate left\n    state.input.keyboard.ArrowRight = false     // Rotate right\n    state.input.keyboard.ArrowUp = false        // Thrust\n    state.input.keyboard.Space = false          // Fire bullet\n    state.input.keyboard.KeyP = false           // Pause\n    state.input.keyboard.KeyQ = false           // Also pause\n    state.input.keyboard.KeyZ = false           // Run dev script (keyup)\n    state.input.keyboard.KeyX = false           // Turn off/on COM dots\n\n    // Setup output links to HTML webpage\n    state.output.context = context\n    // state.output.pageElts = {}    // Done earlier\n    state.output.pageElts.canvas = canvasElt\n    state.output.pageElts.time = document.querySelector(\"#time-left\")\n    state.output.pageElts.fuel = document.querySelector(\"#fuel-left\")\n    state.output.pageElts.ammo = document.querySelector(\"#ammo-left\")\n    state.output.pageElts.health = document.querySelector(\"#health-left\")\n    state.output.pageElts.coin = document.querySelector(\"#coin-found\")\n    state.output.pageElts.x = document.querySelector(\"#pos-x\")\n    state.output.pageElts.y = document.querySelector(\"#pos-y\")\n    state.output.pageElts.u = document.querySelector(\"#vel-u\")\n    state.output.pageElts.v = document.querySelector(\"#vel-v\")\n    state.output.pageElts.anglePos = document.querySelector(\"#ang-pos\")\n    state.output.pageElts.angleVel = document.querySelector(\"#ang-vel\")\n    state.output.pageElts.renderTimeElt = document.querySelector(\"#render-time\")\n\n    state.world.gravity = -120    // (Pixels per second per second!)\n\n    state.world.stars = []\n    state.world.stars.gameCoords = []\n    state.world.stars.canvasCoords = []\n    state.world.stars.colours = []\n    state.world.stars.sizes = []\n    var minSize = 1\n    var maxSize = 4\n    var maxZoomOut = Math.min(\n      state.world.wrapCoords.x / state.output.canvasDims.size.x,\n      state.world.wrapCoords.y / state.output.canvasDims.size.y\n    )\n    // Any more than this and stars need to be displayed in 2 places at once!\n    // This factor is related to the maximum amount the view can zoom in!\n    var maxStarZoomFactor = 1     // 1 => Assuming view doesn't zoom out at all\n    var minStarZoomFactor = 0.0001\n    var maxWeighting = 2\n\n    // Currently - a single zoom for all stars\n    state.world.stars.zoomOut = maxStarZoomFactor * maxZoomOut\n    // Note: this factor of maxStarZoomFactor means that\n    // the most the view can zoom out during gameplay is 1/maxStarZoomFactor\n    // otherwise stars start disappearing off the sides!\n\n    // BETA - a zoom array, one entry for each star.\n    // Looking to make the stars move in parallax!\n    state.world.stars.zoomIns = []\n\n    var starX = 0\n    var starY = 0\n    var starMaxCoordX = state.world.wrapCoords.x\n    var starMaxCoordY = state.world.wrapCoords.y\n    var numberOfStars = 1000\n    var starColours = [\n      \"#F80\", \"#FB0\", \"#FF0\",\n      \"#FF3\", \"#FF8\", \"#FFB\", \"#BFF\", \"#8FF\",\n      \"#3FF\", \"#0FF\", \"#0BF\", \"#08F\",\n      \"#F80\", \"#FB0\", \"#FF0\",\n      \"#FF3\", \"#FF8\", \"#FFB\", \"#BFF\", \"#8FF\",\n      \"#3FF\", \"#0FF\", \"#0BF\", \"#08F\",\n      \"#F80\", \"#FB0\", \"#FF0\",\n      \"#FF3\", \"#FF8\", \"#FFB\", \"#BFF\", \"#8FF\",\n      \"#3FF\", \"#0FF\", \"#0BF\", \"#08F\",\n      \"#FFF\", \"#F0F\", \"#0F0\", \"#F00\", \"#00F\"\n    ]\n    var colourIndex = 0\n    var starZoomFactor = 0\n    for (var i=0; i<numberOfStars; i++) {\n      starX = starMaxCoordX * (-0.5+Math.random())\n      starY = starMaxCoordY * (-0.5+Math.random())\n      state.world.stars.gameCoords.push([starX, starY])\n      state.world.stars.canvasCoords.push([starX, starY])   // Will be overwritten!\n      colourIndex = Math.round(starColours.length * Math.random())\n      state.world.stars.colours.push(starColours[colourIndex])\n      state.world.stars.sizes.push(minSize + (maxSize-minSize)*Math.random()**2)\n\n      // BETA\n      // Have more background stars than foreground - square random number\n      starZoomFactor = maxStarZoomFactor + (minStarZoomFactor-maxStarZoomFactor) * (Math.random() ** maxWeighting)\n      state.world.stars.zoomIns.push(1 / (starZoomFactor * maxZoomOut))\n    }\n\n  }\n\n  window.mainLoop = function(timeLoopStart) {\n    // timeLoopStart is a decimal number, a time precise to 0.005ms :)\n    // Can probably merge these two variables into one?\n    // if (state.control.continueLooping && !state.control.pausing.isPaused) {\n    if (!state.control.pausing.isPaused) {\n      window.requestAnimationFrame(mainLoop)\n      // Make a request for next animation frame\n      // at the top of this animation frame\n    } else {\n      // Log the state on every pause\n      console.log(\"State is\", state)\n    }\n    // Using the 'requestAnimationFrame'\n    // runs this loop once for every\n    // frame displayed by the browser\n    // i.e. browser and main loop are synchronised\n\n    state.control.loopCount++\n    doTiming(timeLoopStart)\n    respondToKeyboardDuringMainLoop()\n    updateViewCoords()\n    recalculateAllPhysicsStats()\n    updateMassesGameCoords()\n    updateMassesCanvasCoords()\n\n    // // Dealing with collisions - more work needed here!\n    // // Can comment these two in and out to turn collision detection on/off\n    findCollisionsBetweenMasses()\n    dealWithCollisions()\n\n    drawCanvas()\n    updateTextInHtml()\n    removeDeadMasses()\n    wrapCoordsOptional()\n    var timeLoopEnd = window.performance.now()\n    state.control.timing.msRenderTime = timeLoopEnd - timeLoopStart\n\n  }\n\n  // RUN THE GAME!!!!\n\n  // Setup the initial game state\n  setupState()\n\n  // Setup monitors on the keyboard to monitor relevant keyboard presses\n  window.addEventListener('keydown', function(event){\n    var eventKeyboardCode = event.code\n    // console.log(eventKeyboardCode)\n    var monitoredCodeState = state.input.keyboard[eventKeyboardCode]\n    // Undefined if not monitored, true or false if monitored\n    if (monitoredCodeState===false) {\n      state.input.keyboard[eventKeyboardCode] = true\n    }\n    respondReliablyToKeyDowns(eventKeyboardCode)\n  })\n  window.addEventListener('keyup', function(event){\n    var eventKeyboardCode = event.code\n    var monitoredCodeState = state.input.keyboard[eventKeyboardCode]\n    if (monitoredCodeState===true) {\n      state.input.keyboard[eventKeyboardCode] = false\n    }\n    respondReliablyToKeyUps(eventKeyboardCode)\n  })\n\n  // Finally... start the mainLoop\n  window.requestAnimationFrame(mainLoop)\n\n}\n\nwindow.addEventListener('load', playGame)\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app.js\n// module id = 0\n// module chunks = 0","var elasticCentredCollision = function(angle, m1, u1, v1, m2, u2, v2) {\n  // The collision angle is between Up and Mass1->Mass2, in a clockwise direction\n\n  // There are two masses, mass 1 and mass 2\n  // Each have a mass and velocity vector, m and (u, v)\n  // giving 6 inputs in total\n  // The output will be a new (u, v) vector for each\n\n  // Find coordinates in which m1*u1 + m2*u2 = 0 and m1*v1 + m2*v2 = 0\n  // this is the centre of momentum frame\n\n  var degresToRadians = Math.PI / 180\n  var massSum = m1+m2\n\n  var uConst = (m1*u1 + m2*u2) / massSum\n  var vConst = (m1*v1 + m2*v2) / massSum\n\n  // New (u, v) coordinates (A) in centre of momentum frame\n  var uA1 = u1 - uConst\n  var vA1 = v1 - vConst\n  var uA2 = u2 - uConst\n  var vA2 = v2 - vConst\n\n  // When an elastic collision occurs, it can be broken into 3 parts:\n  // 1) Rotate (u,v) by -angle\n  // 2) Reflect in y-axis\n  // 3) Rotate by angle\n  // These combine to a cos(2*angle) sin(2*angle) based matrix.\n\n  var cos = Math.cos(degreesToRadians * (2 * angle))\n  var sin = Math.sin(degreesToRadians * (2 * angle))\n  // These are used for Mass 2 (angle is M2 relative from M1)\n  // Do X -> -X for each of these, for mass 1\n\n  // Mass 2 new coords (B)\n  var uB2 = cos * uA2 - sin * vA2\n  var vB2 = -sin * uA2 - cos * vA2\n  // Mass 1 new coords (B)\n  var uB1 = -cos * uA1 + sin * vA1\n  var vB1 = sin * uA1 + cos * vA1\n\n  // Final coords need to add back in uConst, vConst\n  var uC1 = uB1 + uConst\n  var vC1 = vB1 + vConst\n  var uC2 = uB2 + uConst\n  var vC2 = vB2 + vConst\n\n  // These are ready to be returned\n  return [uC1, vC1, uC2, vC2]\n}\n\nmodule.exports = elasticCentredCollision\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/elastic_centred_collision.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}